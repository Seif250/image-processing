using System;
using System.Drawing;
using System.Windows.Forms;
using OpenCvSharp;

namespace MyNamespace
{
    public partial class Form1 : Form
    {
        private Mat? image1;
        private Mat? image2;

        public Form1()
        {
            InitializeComponent();
            this.Icon = new Icon("C:\\Users\\amirt\\MyApp\\img\\icon.ico");
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            this.BackColor = Color.Gray;
        }

        private void openToolStripMenuItem_Click(object sender, EventArgs e)
        {
            using (OpenFileDialog openFileDialog1 = new OpenFileDialog())
            {
                openFileDialog1.FileName = "";
                openFileDialog1.Filter = "JPEG (*.jpg)|*.jpg|Bitmap (*.bmp)|*.bmp|All files (*.*)|*.*";

                if (openFileDialog1.ShowDialog() == DialogResult.OK)
                {
                    try
                    {
                        image1?.Dispose();
                        image1 = Cv2.ImRead(openFileDialog1.FileName, ImreadModes.Color);

                        var aspectRatio = (double)image1.Width / image1.Height;
                        int newWidth = pictureBox1.Width;
                        int newHeight = (int)(newWidth / aspectRatio);

                        if (newHeight > pictureBox1.Height)
                        {
                            newHeight = pictureBox1.Height;
                            newWidth = (int)(newHeight * aspectRatio);
                        }

                        Mat resizedImage = new Mat();
                        Cv2.Resize(image1, resizedImage, new OpenCvSharp.Size(newWidth, newHeight));

                        Bitmap bitmap = MatToBitmap(resizedImage);
                        pictureBox1.Image = bitmap;

                        resizedImage.Dispose();
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show("An error occurred: " + ex.Message);
                    }
                }
            }
        }

        private void RedMenuItem_Click(object sender, EventArgs e)
        {
            ProcessColorChannel(2); // Red channel
        }

        private void GreenMenuItem_Click(object sender, EventArgs e)
        {
            ProcessColorChannel(1); // Green channel
        }

        private void BlueMenuItem_Click(object sender, EventArgs e)
        {
            ProcessColorChannel(0); // Blue channel
        }

        private void GrayScaleMenuItem_Click(object sender, EventArgs e)
        {
            if (image1 == null) return;

            image2?.Dispose();
            image2 = image1.Clone();

            for (int y = 0; y < image2.Rows; y++)
            {
                for (int x = 0; x < image2.Cols; x++)
                {
                    Vec3b color = image2.At<Vec3b>(y, x);
                    byte avg = (byte)((color.Item0 + color.Item1 + color.Item2) / 3);
                    image2.Set(y, x, new Vec3b(avg, avg, avg));
                }
            }

            Bitmap bitmap = MatToBitmap(image2);
            DisplayImagesSideBySide(MatToBitmap(image1), bitmap);
        }

        private void GetHistogramMenuItem_Click(object sender, EventArgs e)
        {
            if (image1 == null) return;

            Bitmap originalBitmap = MatToBitmap(image1);
            Bitmap processedBitmap = image2 != null ? MatToBitmap(image2) : null;

            Bitmap originalHistogram = CreateHistogram(originalBitmap, 200); // Adjust height as needed
            Bitmap processedHistogram = processedBitmap != null ? CreateHistogram(processedBitmap, 200) : null;

            // Combine the original image and its histogram
            Bitmap originalWithHist = new Bitmap(originalBitmap.Width, originalBitmap.Height + originalHistogram.Height);
            using (Graphics g = Graphics.FromImage(originalWithHist))
            {
                g.Clear(Color.Gray);
                g.DrawImage(originalBitmap, 0, 0, originalBitmap.Width, originalBitmap.Height);
                g.DrawImage(originalHistogram, 0, originalBitmap.Height, originalHistogram.Width, originalHistogram.Height);
            }

            // Combine the processed image and its histogram if it exists
            Bitmap processedWithHist = null;
            if (processedBitmap != null && processedHistogram != null)
            {
                processedWithHist = new Bitmap(processedBitmap.Width, processedBitmap.Height + processedHistogram.Height);
                using (Graphics g = Graphics.FromImage(processedWithHist))
                {
                    g.Clear(Color.Gray);
                    g.DrawImage(processedBitmap, 0, 0, processedBitmap.Width, processedBitmap.Height);
                    g.DrawImage(processedHistogram, 0, processedBitmap.Height, processedHistogram.Width, processedHistogram.Height);
                }
            }

            // Combine both images with histograms side by side
            Bitmap finalDisplay = new Bitmap(originalWithHist.Width + (processedWithHist?.Width ?? 0), originalWithHist.Height);
            using (Graphics g = Graphics.FromImage(finalDisplay))
            {
                g.DrawImage(originalWithHist, 0, 0, originalWithHist.Width, originalWithHist.Height);
                if (processedWithHist != null)
                {
                    g.DrawImage(processedWithHist, originalWithHist.Width, 0, processedWithHist.Width, processedWithHist.Height);
                }
            }

            pictureBox1.Image = finalDisplay;
        }

        private void HistogramEqualizationMenuItem_Click(object sender, EventArgs e)
        {
            if (image1 == null) return;

            // Clone image1 to image2
            image2?.Dispose();
            image2 = image1.Clone();

            Mat grayImage = new Mat();
            Cv2.CvtColor(image2, grayImage, ColorConversionCodes.BGR2GRAY);

            int[] histogram = new int[256];
            for (int y = 0; y < grayImage.Rows; y++)
            {
                for (int x = 0; x < grayImage.Cols; x++)
                {
                    byte intensity = grayImage.At<byte>(y, x);
                    histogram[intensity]++;
                }
            }

            int totalPixels = grayImage.Rows * grayImage.Cols;
            double[] pdf = new double[256];
            double[] cdf = new double[256];
            pdf[0] = (double)histogram[0] / totalPixels;
            cdf[0] = pdf[0];

            for (int i = 1; i < 256; i++)
            {
                pdf[i] = (double)histogram[i] / totalPixels;
                cdf[i] = cdf[i - 1] + pdf[i];
            }

            Mat equalizedImage = new Mat(grayImage.Size(), grayImage.Type());
            for (int y = 0; y < grayImage.Rows; y++)
            {
                for (int x = 0; x < grayImage.Cols; x++)
                {
                    byte intensity = grayImage.At<byte>(y, x);
                    byte newIntensity = (byte)(cdf[intensity] * 255);
                    equalizedImage.Set(y, x, newIntensity);
                }
            }

            Bitmap originalBitmap = MatToBitmap(image1); // Use image1 for original
            Bitmap equalizedBitmap = MatToBitmap(equalizedImage);
            Bitmap originalHistogram = CreateHistogram(originalBitmap, 200);
            Bitmap equalizedHistogram = CreateHistogram(equalizedBitmap, 200);

            DisplayImagesAndHistograms(originalBitmap, equalizedBitmap, originalHistogram, equalizedHistogram);
        }

        private Bitmap CreateHistogram(Bitmap bitmap, int height)
        {
            int[] histogramR = new int[256];
            int[] histogramG = new int[256];
            int[] histogramB = new int[256];

            for (int y = 0; y < bitmap.Height; y++)
            {
                for (int x = 0; x < bitmap.Width; x++)
                {
                    Color color = bitmap.GetPixel(x, y);
                    histogramR[color.R]++;
                    histogramG[color.G]++;
                    histogramB[color.B]++;
                }
            }

            int max = Math.Max(Math.Max(histogramR.Max(), histogramG.Max()), histogramB.Max());

            Bitmap histImage = new Bitmap(256, height);
            using (Graphics g = Graphics.FromImage(histImage))
            {
                g.Clear(Color.White);

                for (int i = 0; i < 256; i++)
                {
                    int rHeight = (int)(histogramR[i] * height / max);
                    int gHeight = (int)(histogramG[i] * height / max);
                    int bHeight = (int)(histogramB[i] * height / max);

                    g.DrawLine(Pens.Red, i, height, i, height - rHeight);
                    g.DrawLine(Pens.Green, i, height, i, height - gHeight);
                    g.DrawLine(Pens.Blue, i, height, i, height - bHeight);
                }
            }

            return histImage;
        }

        private void DisplayHistograms(Bitmap originalHistogram, Bitmap processedHistogram)
        {
            Bitmap combined = new Bitmap(originalHistogram.Width * 2, originalHistogram.Height);

            using (Graphics g = Graphics.FromImage(combined))
            {
                g.DrawImage(originalHistogram, 0, 0, originalHistogram.Width, originalHistogram.Height);

                if (processedHistogram != null)
                {
                    g.DrawImage(processedHistogram, originalHistogram.Width, 0, processedHistogram.Width, processedHistogram.Height);
                }
            }

            pictureBox1.Image = combined;
        }

        private void DisplayImagesAndHistograms(Bitmap original, Bitmap equalized, Bitmap originalHist, Bitmap equalizedHist)
        {
            // Resize histograms to match the width of the images
            Bitmap resizedOriginalHist = new Bitmap(original.Width, originalHist.Height);
            using (Graphics g = Graphics.FromImage(resizedOriginalHist))
            {
                g.DrawImage(originalHist, 0, 0, original.Width, originalHist.Height);
            }

            Bitmap resizedEqualizedHist = new Bitmap(equalized.Width, equalizedHist.Height);
            using (Graphics g = Graphics.FromImage(resizedEqualizedHist))
            {
                g.DrawImage(equalizedHist, 0, 0, equalized.Width, equalizedHist.Height);
            }

            // Combine each image with its histogram vertically
            Bitmap originalWithHist = new Bitmap(original.Width, original.Height + resizedOriginalHist.Height);
            using (Graphics g = Graphics.FromImage(originalWithHist))
            {
                g.DrawImage(original, 0, 0, original.Width, original.Height);
                g.DrawImage(resizedOriginalHist, 0, original.Height, resizedOriginalHist.Width, resizedOriginalHist.Height);
            }

            Bitmap equalizedWithHist = new Bitmap(equalized.Width, equalized.Height + resizedEqualizedHist.Height);
            using (Graphics g = Graphics.FromImage(equalizedWithHist))
            {
                g.DrawImage(equalized, 0, 0, equalized.Width, equalized.Height);
                g.DrawImage(resizedEqualizedHist, 0, equalized.Height, resizedEqualizedHist.Width, resizedEqualizedHist.Height);
            }

            // Combine the two vertical pairs side by side
            Bitmap finalDisplay = new Bitmap(originalWithHist.Width + equalizedWithHist.Width, originalWithHist.Height);
            using (Graphics g = Graphics.FromImage(finalDisplay))
            {
                g.DrawImage(originalWithHist, 0, 0, originalWithHist.Width, originalWithHist.Height);
                g.DrawImage(equalizedWithHist, originalWithHist.Width, 0, equalizedWithHist.Width, equalizedWithHist.Height);
            }

            pictureBox1.Image = finalDisplay;
        }

        private void ProcessColorChannel(int channelIndex)
        {
            if (image1 == null) return;

            image2?.Dispose();
            image2 = image1.Clone();

            Mat[] channels = Cv2.Split(image2);

            for (int i = 0; i < channels.Length; i++)
            {
                if (i != channelIndex)
                {
                    channels[i].SetTo(0);
                }
            }

            Cv2.Merge(channels, image2);

            Bitmap bitmap = MatToBitmap(image2);
            DisplayImagesSideBySide(MatToBitmap(image1), bitmap);
        }

        private void DisplayImagesSideBySide(Bitmap original, Bitmap processed)
        {
            Bitmap combined = new Bitmap(original.Width * 2, original.Height);

            using (Graphics g = Graphics.FromImage(combined))
            {
                g.DrawImage(original, 0, 0, original.Width, original.Height);
                g.DrawImage(processed, original.Width, 0, processed.Width, processed.Height);
            }

            pictureBox1.Image = combined;
        }

        private Bitmap MatToBitmap(Mat mat)
        {
            using (var ms = mat.ToMemoryStream())
            {
                return new Bitmap(ms);
            }
        }

        private Mat BitmapToMat(Bitmap bitmap)
        {
            using (var ms = new System.IO.MemoryStream())
            {
                bitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Bmp);
                return Mat.FromStream(ms, ImreadModes.Color);
            }
        }

        // Filter Methods
        private void GaussianBlurMenuItem_Click(object sender, EventArgs e)
        {
            if (image1 == null) return;

            image2?.Dispose();
            image2 = new Mat();
            Cv2.GaussianBlur(image1, image2, new OpenCvSharp.Size(31, 31), 0);

            DisplayImagesSideBySide(MatToBitmap(image1), MatToBitmap(image2));
        }

        private void SobelEdgeMenuItem_Click(object sender, EventArgs e)
        {
            if (image1 == null) return;

            image2?.Dispose();
            image2 = new Mat();
            Cv2.CvtColor(image1, image2, ColorConversionCodes.BGR2GRAY);
            Cv2.Sobel(image2, image2, MatType.CV_8U, 1, 1);

            DisplayImagesSideBySide(MatToBitmap(image1), MatToBitmap(image2));
        }

        private void BrightnessAdjustmentMenuItem_Click(object sender, EventArgs e)
        {
            if (image1 == null) return;

            image2?.Dispose();
            image2 = image1.Clone();
            image2.ConvertTo(image2, -1, 1, 50); // Increase brightness by 50

            DisplayImagesSideBySide(MatToBitmap(image1), MatToBitmap(image2));
        }

        private void NegativeFilterMenuItem_Click(object sender, EventArgs e)
        {
            if (image1 == null) return;

            image2?.Dispose();
            image2 = new Mat();
            Cv2.BitwiseNot(image1, image2);

            DisplayImagesSideBySide(MatToBitmap(image1), MatToBitmap(image2));
        }
    }
}